# Implementation Plan: Component Quality Review and Template Cleanup

**Branch**: `004-component-review` | **Date**: 2025-11-16 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/004-component-review/spec.md`

## Summary

Perform comprehensive code quality review of early components (Button, Badge, Alert, Avatar) to identify improvements based on patterns learned from later implementations (Toast, Modal, Select, Pagination), plus eliminate unused Jinja base template to reduce technical debt. This is a refactoring and cleanup task focused on consistency, maintainability, and code quality without adding new features or breaking existing functionality.

## Technical Context

**Language/Version**: Python 3.11+ (existing project requirement)
**Primary Dependencies**: htmy 0.1.0+, FastAPI 0.104.0+, fasthx 0.1.0+, Jinja2 3.1+
**Storage**: N/A (stateless UI component library)
**Testing**: pytest with asyncio support, syrupy for snapshots, mypy strict mode
**Target Platform**: Linux/macOS/Windows (Python package)
**Project Type**: Single Python package with component library
**Performance Goals**: Test suite execution <5 seconds, 90%+ coverage maintained
**Constraints**: 100% backward compatibility with existing tests (187 tests must pass), no public API changes, maintain 90%+ coverage
**Scale/Scope**: 8 existing components, ~14 component files, 187 existing tests

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

Verify this feature plan complies with constitution principles (`.specify/memory/constitution.md`):

- **TDD Compliance**: ✅ Plan includes test-first validation - all 187 existing tests must pass before/after changes. New tests required before any component modifications.
- **Type Safety**: ✅ Plan requires mypy strict mode validation on all changes. Improvements must maintain 100% type coverage.
- **Component Value**: ✅ This is a review task, not component creation. Validates existing components against value criteria.
- **Architecture**: ✅ Plan respects hybrid Jinja + htmy pattern. Template cleanup aligns with Jinja for layouts principle.
- **Quality Gates**: ✅ Plan explicitly requires 90%+ coverage, ruff linting, and mypy checks on all changes.

**Status**: ✅ All constitution principles satisfied. No violations requiring justification.

## Project Structure

### Documentation (this feature)

```text
specs/004-component-review/
├── plan.md              # This file (/speckit.plan command output)
├── research.md          # Phase 0: Component pattern analysis
├── data-model.md        # Phase 1: Review findings data model
├── quickstart.md        # Phase 1: Review workflow guide
├── contracts/           # Phase 1: Quality checklist contract
│   └── component-quality-checklist.md
└── tasks.md             # Phase 2: Generated by /speckit.tasks (NOT created by /speckit.plan)
```

### Source Code (repository root)

```text
# Existing structure - no new directories
src/flowbite_htmy/
├── components/          # Target: Button, Badge, Alert, Avatar for review
│   ├── button.py       # Earliest implementation (check patterns)
│   ├── badge.py        # Early implementation
│   ├── alert.py        # Early implementation
│   ├── avatar.py       # Early implementation (Phase 1 finale)
│   ├── toast.py        # Reference: Latest patterns (Phase 2C)
│   ├── modal.py        # Reference: Phase 2 patterns
│   ├── select.py       # Reference: Phase 2A patterns
│   └── pagination.py   # Reference: Phase 2A patterns
├── base/
│   ├── classes.py      # ClassBuilder utility (check usage)
│   └── context.py      # ThemeContext utility (check usage)
└── types/              # Color, Size, ButtonVariant enums

tests/test_components/   # All existing tests must continue passing
├── test_button.py      # ~30 tests
├── test_badge.py       # ~20 tests
├── test_alert.py       # ~20 tests
├── test_avatar.py      # ~18 tests
└── [other test files]  # 187 total tests

examples/
├── templates/
│   ├── base.html.jinja           # Target: Check if unused
│   └── showcase-layout.html.jinja # Target: Check if active
└── showcase.py         # Main app using templates
```

**Structure Decision**: This is a refactoring task on existing code structure. No new directories or major restructuring required. Focus is on reviewing and improving existing component files while maintaining test compatibility.

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

N/A - No constitution violations. All principles satisfied.

---

## Phase 0: Research & Pattern Analysis

**Goal**: Analyze patterns from later components (Toast, Modal, Select, Pagination) and compare against early components (Button, Badge, Alert, Avatar) to identify concrete improvement opportunities.

### Research Tasks

#### R1: Template Usage Analysis
**Question**: Which Jinja base template is actively used and which can be safely removed?

**Research Steps**:
1. Search `examples/showcase.py` for template references (Jinja2 `get_template()` or `render_template()`)
2. Search all `examples/*.py` files for references to `base.html.jinja` and `showcase-layout.html.jinja`
3. Check git history: `git log --all --full-history -- examples/templates/base.html.jinja`
4. Verify template is not imported via indirect means (template inheritance, includes)

**Expected Outcome**: Identify which template is unused and confirm safe removal.

#### R2: Component Pattern Comparison
**Question**: What patterns exist in later components (Toast, Modal, Select) that are missing or inconsistent in early components?

**Research Areas**:
1. **HTMX Attribute Coverage**:
   - Toast has: `hx_get, hx_post, hx_put, hx_delete, hx_patch, hx_target, hx_swap, hx_trigger, hx_push_url, hx_select`
   - Compare: What HTMX attrs do Button, Badge, Alert, Avatar support?
   - Pattern: Full HTMX coverage vs. partial coverage

2. **Dark Mode Class Patterns**:
   - Toast pattern: Always include `dark:` prefixed classes in ClassBuilder
   - Compare: Do early components consistently include dark mode classes?
   - Look for: Conditional dark mode (anti-pattern) vs. always-included (correct)

3. **ClassBuilder Usage Consistency**:
   - Toast pattern: Use `ClassBuilder` for all class building, `.merge(self.class_)` at end
   - Compare: Do early components use ClassBuilder consistently or mix approaches?

4. **Type Annotations**:
   - Toast pattern: Full type hints including `Component`, `Context`, `SafeStr | None`
   - Compare: Are early components fully typed or missing hints?

5. **Docstring Quality**:
   - Toast pattern: Class docstring + examples + prop docstrings
   - Compare: Do early components have comprehensive documentation?

6. **Prop Naming Conventions**:
   - Toast pattern: `class_` (trailing underscore), `type_` for reserved words
   - Compare: Consistent naming in early components?

**Research Method**: Side-by-side code comparison using file reads and grep patterns.

**Expected Outcome**: Categorized list of pattern differences with specific line number references.

#### R3: Test Coverage Baseline
**Question**: What is the current test coverage baseline for early components, and what patterns exist in later component tests?

**Research Steps**:
1. Run `pytest --cov=src/flowbite_htmy/components/button --cov-report=term-missing` for each early component
2. Compare test structures: Toast tests (23 tests, 92% coverage) vs. early component tests
3. Identify untested code paths in early components
4. Check for snapshot tests (syrupy) usage consistency

**Expected Outcome**: Coverage report for each early component + gap analysis.

#### R4: Breaking Change Risk Assessment
**Question**: What types of changes could break existing tests or public APIs?

**Research Areas**:
1. **Public API Surface**:
   - Component `__init__` signatures (prop names, types, defaults)
   - Component output HTML structure (tests may assert on specific HTML)
   - Exported names from `__init__.py`

2. **Test Dependencies**:
   - Search test files for assertions on specific HTML patterns
   - Identify fragile tests that depend on exact class ordering or HTML structure
   - Find tests that use snapshots (changes will update snapshots but need validation)

3. **Showcase Dependencies**:
   - Check `examples/*.py` for component usage patterns
   - Verify showcase apps would still work with prop changes

**Expected Outcome**: Risk matrix categorizing changes by breaking vs. safe.

### Research Output: research.md

**Structure**:
```markdown
# Component Quality Review Research

## Template Usage Findings
- Active template: [name]
- Unused template: [name]
- Evidence: [references from showcase.py]
- Safe to remove: [Yes/No with rationale]

## Pattern Comparison Matrix

| Pattern Area | Toast/Modal/Select | Button | Badge | Alert | Avatar | Action Needed |
|--------------|-------------------|--------|-------|-------|--------|---------------|
| HTMX Coverage | Full (10 attrs) | Partial | ? | ? | ? | Standardize? |
| Dark Mode | Always-included | ? | ? | ? | ? | Check consistency |
| ClassBuilder | Consistent | ? | ? | ? | ? | Audit usage |
| Type Hints | 100% | ? | ? | ? | ? | Fill gaps |
| Docstrings | Comprehensive | ? | ? | ? | ? | Enhance |

## Improvement Recommendations (Prioritized)

### High Priority (Consistency Issues)
1. **[Issue Name]**: [Description]
   - Affected components: [list]
   - Current pattern: [example]
   - Target pattern: [example from Toast]
   - Breaking risk: [Low/Medium/High]

### Medium Priority (Nice-to-Haves)
[...]

### Low Priority (Optional)
[...]

## Safe Change Criteria
- Changes that don't modify component output HTML
- Changes that add optional props with defaults
- Changes that improve internal implementation (ClassBuilder usage)
- Changes that enhance docstrings or type hints

## Breaking Change Risks
- Changing prop names or types
- Changing default prop values
- Changing output HTML structure
- Removing public props
```

---

## Phase 1: Design Artifacts

**Goal**: Define data models for review findings and create quality checklist contract for validating components.

### 1.1 Data Model (data-model.md)

**Purpose**: Structure for capturing component review findings.

**Entities**:

#### ComponentReview
Represents analysis results for a single component.

**Fields**:
- `component_name` (str): Component being reviewed (e.g., "Button", "Badge")
- `file_path` (str): Absolute path to component file
- `implementation_date` (str): Date from git log (first commit)
- `current_coverage` (float): Test coverage percentage (0-100)
- `test_count` (int): Number of tests for this component
- `identified_issues` (list[Issue]): List of identified problems
- `proposed_improvements` (list[Improvement]): List of recommended changes
- `priority` (str): "high", "medium", "low" based on impact
- `backward_compatible` (bool): Whether improvements maintain compatibility

**Relationships**:
- Has many `Issue` records
- Has many `Improvement` records

#### Issue
Represents a specific problem found in a component.

**Fields**:
- `issue_type` (str): Category - "pattern_inconsistency", "missing_feature", "documentation_gap", "type_hint_missing"
- `severity` (str): "critical", "major", "minor"
- `description` (str): Clear explanation of the issue
- `current_code_example` (str): Code snippet showing current implementation
- `file_location` (str): "file:line" reference
- `affects_functionality` (bool): Whether this impacts component behavior

**Relationships**:
- Belongs to `ComponentReview`

#### Improvement
Represents a proposed fix or enhancement.

**Fields**:
- `improvement_type` (str): "add_htmx_attrs", "fix_dark_mode", "enhance_docs", "refactor_classbuilder", "add_type_hints"
- `description` (str): What to change
- `target_pattern` (str): Code example showing desired pattern (from Toast/Modal)
- `breaking_risk` (str): "none", "low", "medium", "high"
- `estimated_effort` (str): "trivial" (<30 min), "small" (<2 hrs), "medium" (2-4 hrs), "large" (4+ hrs)
- `depends_on` (list[str]): Other improvements that must be done first

**Relationships**:
- Belongs to `ComponentReview`
- Addresses one or more `Issue` records

#### TemplateUsage
Represents template file usage analysis.

**Fields**:
- `template_name` (str): Template filename
- `file_path` (str): Absolute path to template
- `used_by` (list[str]): List of files referencing this template
- `last_modified` (str): Git timestamp
- `can_remove` (bool): Safe to delete
- `removal_blockers` (list[str]): Reasons why it can't be removed (if any)

**State Transitions**: N/A (this is a review, not a workflow)

### 1.2 API Contract (contracts/component-quality-checklist.md)

**Purpose**: Define the quality checklist that all components should pass.

**Contract Format**:
```markdown
# Component Quality Checklist

## Metadata
- Version: 1.0.0
- Last Updated: 2025-11-16
- Applies To: All htmy components in flowbite-htmy

## Quality Criteria

### 1. Type Safety
- [ ] All props have explicit type hints
- [ ] `htmy()` method returns `Component` type
- [ ] `context: Context` parameter typed
- [ ] No `Any` types without justification
- [ ] Component passes `mypy --strict`

### 2. HTMX Integration
- [ ] Supports at minimum: `hx_get`, `hx_post`, `hx_target`
- [ ] For interactive components, supports: `hx_swap`, `hx_trigger`
- [ ] For advanced components, supports full set (10 attrs)
- [ ] HTMX attrs have `| None` type and `None` default

### 3. Dark Mode Support
- [ ] All color classes include `dark:` variants
- [ ] Dark classes always included (not conditional)
- [ ] Uses `ThemeContext.from_context(context)` if needed
- [ ] Tested in both light and dark modes

### 4. ClassBuilder Usage
- [ ] Uses `ClassBuilder` for class string construction
- [ ] Base classes added first via constructor
- [ ] Conditional classes use `.add_if()`
- [ ] Custom classes merged last via `.merge(self.class_)`

### 5. Documentation
- [ ] Class has comprehensive docstring
- [ ] Docstring includes usage examples
- [ ] All public props have docstrings
- [ ] Special patterns or gotchas documented

### 6. Prop Conventions
- [ ] Reserved words use trailing underscore (e.g., `class_`, `type_`)
- [ ] Boolean props default to `False` (or sensible default)
- [ ] Required props come before optional props
- [ ] Consistent naming with other components

### 7. Test Coverage
- [ ] >90% coverage (enforced by pytest config)
- [ ] Tests for default rendering
- [ ] Tests for all variants (color, size, style)
- [ ] Tests for HTMX attributes
- [ ] Tests for dark mode
- [ ] Tests for custom classes
- [ ] Edge case tests (None, empty string, etc.)

### 8. Backward Compatibility
- [ ] No breaking changes to existing props
- [ ] No changes to component output HTML structure
- [ ] No removal of public props
- [ ] Additions use optional props with defaults

## Scoring
- **Critical**: Type Safety, Backward Compatibility (must pass)
- **Important**: Dark Mode, ClassBuilder, Test Coverage (should pass)
- **Nice-to-Have**: HTMX (full set), Documentation (can improve)

## Compliance Levels
- **Full Compliance**: All criteria pass
- **Substantial Compliance**: Critical + Important pass, 1-2 Nice-to-Have gaps
- **Partial Compliance**: Critical pass, some Important gaps
- **Non-Compliant**: Critical failures
```

### 1.3 TDD Quickstart (quickstart.md)

**Purpose**: Step-by-step guide for reviewing and improving components following TDD.

**Content Structure**:
```markdown
# Component Review TDD Workflow

## Prerequisites
- [ ] All 187 existing tests passing
- [ ] `research.md` complete with findings
- [ ] Improvement priorities identified

## Workflow Steps

### Step 1: Baseline Validation
1. Run full test suite: `pytest`
2. Verify 187 tests pass
3. Check coverage: `pytest --cov=src/flowbite_htmy/components`
4. Commit current state as baseline

### Step 2: Component-by-Component Review
For each component (Button, Badge, Alert, Avatar):

#### 2.1 Read Current Implementation
1. Open component file
2. Open test file
3. Review against quality checklist

#### 2.2 Identify Improvements
1. Cross-reference with research.md findings
2. Prioritize: High → Medium → Low
3. Filter for backward compatible changes only

#### 2.3 TDD Cycle for Each Improvement
**RED Phase**:
1. Write test for improved behavior (if needed)
2. Run test - should fail OR existing tests should pass (for non-behavioral changes)

**GREEN Phase**:
1. Make minimal change to component
2. Run tests - should pass
3. Verify all 187 tests still pass

**REFACTOR Phase**:
1. Clean up implementation
2. Run tests - should still pass
3. Check coverage maintains >90%

#### 2.4 Validation Checklist
After each improvement:
- [ ] All 187 tests pass
- [ ] Coverage >90%
- [ ] `mypy src/flowbite_htmy` passes
- [ ] `ruff check src/flowbite_htmy` passes
- [ ] `ruff format src/flowbite_htmy` clean
- [ ] Showcase app still runs: `python examples/showcase.py`

### Step 3: Template Cleanup
1. Verify unused template identified in research.md
2. Confirm no references in codebase: `grep -r "unused-template.html.jinja" examples/`
3. Remove file
4. Run showcase app - verify still works
5. Commit with clear message

### Step 4: Documentation
1. Create `docs/component-quality-standards.md` if pursuing User Story 3 (P3)
2. Document learned patterns
3. Update CLAUDE.md if new patterns emerge

## Safety Checks
Before committing any change:
- `pytest` - all tests pass
- `python examples/showcase.py` - app runs
- Manual verification of changed component in showcase
```

### 1.4 Agent Context Update

Run the agent context update script:
```bash
.specify/scripts/bash/update-agent-context.sh claude
```

**Purpose**: Update `.specify/memory/claude-context.md` with technologies from this feature.

**New Technologies** (if not already present):
- Component review patterns
- Quality checklist methodology
- Refactoring workflow with TDD
- Pattern analysis across component versions

**Note**: Script auto-detects technologies and updates between markers. Manual additions preserved.

---

## Phase 2: Implementation Tasks

**Note**: Tasks are generated by the `/speckit.tasks` command, NOT by `/speckit.plan`. This phase documents the structure and approach for task generation.

### Task Generation Strategy

Tasks will be organized into the three user stories (P1, P2, P3) with TDD cycles:

**P1: Template Cleanup** (3-5 tasks):
1. Research: Identify unused template
2. Verify: Check for references
3. Remove: Delete file
4. Test: Verify showcase works
5. Document: Commit message

**P2: Component Review** (12-20 tasks per component × 4 components = 48-80 tasks):
For each component (Button, Badge, Alert, Avatar):
1. Analyze against checklist (1 task)
2. For each identified improvement:
   - Write test (if behavioral change)
   - Implement improvement
   - Validate quality gates
3. Final validation (1 task)

**P3: Quality Standards Documentation** (3-5 tasks):
1. Extract patterns from review
2. Write quality standards doc
3. Add examples from components
4. Update CLAUDE.md references
5. Review and finalize

### Task Dependencies
- P1 can be done independently (no dependencies)
- P2 tasks are per-component (can parallelize across components)
- P2 within a component must be sequential (TDD cycle)
- P3 depends on P2 completion (needs learned patterns)

### Quality Gates (Applied to All Tasks)
- All existing tests pass (187 tests)
- Coverage maintains >90%
- Mypy strict passes
- Ruff linting passes
- Showcase app runs without errors

---

## Implementation Notes

### Key Principles
1. **Backward Compatibility is Non-Negotiable**: No breaking changes to public APIs or component output
2. **TDD is Mandatory**: Every change validated by tests (existing or new)
3. **Refactoring, Not Rewriting**: Improve existing code, don't start from scratch
4. **Practical Over Perfect**: Focus on genuine improvements, not theoretical perfectionism
5. **Pattern Consistency**: Use Toast/Modal as reference for modern patterns

### Risk Mitigation
- Run full test suite after every change
- Commit frequently with clear messages
- Verify showcase app after each component
- Use feature branch (004-component-review) for isolation
- Maintain baseline commit for rollback if needed

### Success Validation
- SC-001: Unused template removed, showcase works ✓
- SC-002: ≥3 improvements identified (expect 5-10 from research) ✓
- SC-003: 187 tests passing after all changes ✓
- SC-004: Coverage >90% maintained ✓
- SC-005: No [NEEDS CLARIFICATION] introduced (all answered in research) ✓

---

## Post-Phase 1 Constitution Re-Check

*Re-verify constitution compliance after design artifacts created:*

- **TDD Compliance**: ✅ quickstart.md enforces test-first cycle for all changes
- **Type Safety**: ✅ Quality checklist includes type hint requirements, mypy validation
- **Component Value**: ✅ Review validates existing components, no new components created
- **Architecture**: ✅ Template cleanup aligns with hybrid pattern (Jinja for layouts)
- **Quality Gates**: ✅ Every task includes coverage, linting, type checking validation

**Final Status**: ✅ All constitution principles maintained post-design.

---

## Artifacts Generated

### Phase 0 Outputs
- `research.md` - Pattern analysis and improvement recommendations

### Phase 1 Outputs
- `data-model.md` - ComponentReview, Issue, Improvement, TemplateUsage entities
- `contracts/component-quality-checklist.md` - Quality criteria for components
- `quickstart.md` - TDD workflow for component review
- `.specify/memory/claude-context.md` - Updated with review methodologies

### Phase 2 Outputs (via `/speckit.tasks`)
- `tasks.md` - Dependency-ordered implementation tasks

---

**Plan Status**: ✅ Complete - Ready for `/speckit.tasks`

**Next Command**: `/speckit.tasks` - Generate implementation task list
